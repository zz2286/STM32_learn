## BK4819_SPI_#_HAL_GPIO_EXTI_USART_DMA_SPI
STM32F103C8T6 基于 CubeMX 生成代码，并由 VSCode 编辑，再由 Keil 编译的项目。

## Update Record  

|    Date    | Verison | Details |
| ---------- | ------- | ---------------------- |
| 2024.07.02 |  v 1.0  | 本demo暂时只是早期验证SPI接口的代码版本。 |
| 2024.07.0_ |  v 1._  | ~~本demo暂时只是早期验证SPI接口的代码版本。~~ |
| 2024.07.0_ |  v 1._  | ~~本demo暂时只是早期验证SPI接口的代码版本。~~ |

# SPI接口控制BK4819芯片开发板

针对 BK4819 芯片和开发板，通过GPIO模拟SPI时序进行通信，实现读写对应地址的寄存器值以实现相关功能。
本demo的所谓SPI只是 针对 BK4819 数据手册所要求的 SPI 时序图进行的 软件GPIO模拟SPI通信，并未添加STM32的SPI模块配置。

## BK4819 控制逻辑

### 1. Mian()
调用 **RF_Initial** 初始化。
### 2. RF_Initial()
包括 SoftReset, PowerUp, Setup.

## SPI 接口模拟
三线SPI收发, 包含以下三引脚/线
- SCL - 时钟线 Clock.
- SDA - 数据线 Data.
- SCN - 控制线 Control.

对应STM32的GPIO引脚

| STM32_IO | STM32_SPI | Label |
| -------- | --------- | ----- |
| PA4      | SPI1_NSS  | SCN   |
| PA5      | SPI1_SCK  | SCL   |
| PA7      | SPI1_MOSI | SDA   |


**对于BK4819芯片而言**
当SCN为低电平时，SPI接口被选中并开始通信。  
当SCN为高电平时，SPI接口被禁止，通信结束。 


**对于STM32而言**
- PA4 推挽输出 内部上拉
- PA5 推挽输出 内部下拉
- PA7 推挽输出 内部下拉 / 输入
<!-- - PA7 开漏输出 外部上拉电阻 (用作准双向输入输出口)-->

**STM32 作为主机，BK4819 作为从机**
**1. STM32 输出 SCN 低电平，控制 BK4819 进入收发状态。**
**2. 输出模式下，STM32 输出 SCK 上升沿，STM32 输出 BK4819 读取 SDA 位数据。**
**3. 输入模式下，STM32 输出 SCK 下降沿，控制 BK4819 装载 SDA 位数据。**
**4. 输入模式下，STM32 输出 SCK 上升沿，自身 STM32 读取 SDA 位数据。**
**5. STM32 输出 SCN 高电平，控制 BK4819 结束收发状态。**


**主机(单片机) 按地址向 从机(BK4819) 发送数据**  
`RF_Write(u8 addr, u16 data)` + `SPI_Send_Byte(u8 txd)`：  
1. **主机**将 SDA 切换到输出模式，将 SCN 和 SCK 输出低电平，准备开始发送地址和数据。  
2. **主机**先将 SCK 输出低电平，等 SDA 输出装载位数据后，再将 SCK 输出高电平，制造 SCK 上升沿。  
3. **主机**通过 SCK 上升沿8次，使 SDA **从高到低位**发送8位数据，驱使**从机**在SCK上升沿读取8位数据。  
5. 按以上步骤 2.3. **主机**先发送一次8位地址，再分两次依次发送高8位和低8位的数据。
4. **主机**将 SCN 输出高电平，平结束发送。  

**主机(单片机) 按地址读取 从机(BK4819) 一字长数据**  
`RF_Read(u8 addr)` + `SPI_Get_Word()`：  
1. **主机**将 SDA 切换到输出模式，将 SCN 和 SCK 输出低电平，准备开始发送地址字节。  
2. **主机**通过 SCK 上升沿8次，使 SDA **从高到低位**发送8位地址数据，驱使**从机**在SCK上升沿读取8位地址。  
3. 随后延时2us，在此期间SCK保持高电平。  
4. **主机**将 SDA 切换到输入模式，将 SCK 输出低电平 (拉低tCDV后**从机**输出 SDA 有效) 以开始接收数据。  
5. **主机**将 SCK (在拉低tNXT后)输出高电平，开始在每次 SCK 上升沿读取 SDA 位数据。  
6. **主机**读取 SDA 位数据后将 SCK 输出低电平，驱使**从机**在 SCK 下降沿重新装载 SDA 位数据。  
7. 直至接收到16位**从高到低位**的内容数据后，**主机**将 SCN 输出高电平，结束接收。  

# 其它的基础功能

**按键轮询功能**
按键 PA2, 下降沿有效, 按下时阻塞且反置LED, 松开后退出阻塞.  
按键 PA3, 按下点亮LED, 松开熄灭LED。  

**按键外部中断**
按键 PA0, 上升沿有效, 松开点亮LED.  
按键 PA1, 下降沿有效, 按下熄灭LED.  

**串口收发功能**
使用的是 通用同步收发器`USART` 的异步模式 `UART`  
串口连接:  
- USART1_Rx/Tx - PA10/PA9, 接 CH340 的USB串口模块, 波特率 115200;  
- (未实现)USART2_Rx/Tx - PB11/PB10, 接 HC-05 的蓝牙串口模块, 波特率 9600;  

一、非中断 收发数据  
1. 非中断 串口收发  
2. 输入输出接口重定向  
3. 非中断 调试输出日志  

二、串口指令读取与外设控制  
- 自定义函数: 读取数据-识别指令-控制外设。  

三、串口接收不定长字符串数据(多种方案)  
1. 非中断 接收不定长字符串  
2. 中断 接收不定长字符串  
- 方案一: 单次收取一字节, 收到结束符 或 缓冲区溢出 时处理数据。  
    - 使用 `UART_Receive_IT` 函数, 单次接收一个字符。  
    - 使用 `UART_RxCpltCallback` 函数, 处理字符并开启下一次接收。  
- 方案二: 单次收取整个缓冲区, 收到指定长度 或 空闲中断 时处理数据。  
    - 使用 `HAL_UART_Receive_IT` 函数收取指定长度字符。  
    - 在 `USART1_IRQHandler` 中断处理函数中判定串口空闲标志位, 并调用自定义的 `AAA_UART_IDLE_Callback` 空闲中断回调函数。  
    - 在自定义的 `AAA_UART_IDLE_Callback` 空闲中断回调函数中, 使用 `UART_Start_Receive_IT` 函数开启下一次接收。  
- 方案三: 方案二的简化版。  
    - 使用 `HAL_UARTEx_ReceiveToIdle_IT` 和 `HAL_UARTEx_RxEventCallback` 函数。  
3. 中断+DMA 接收不定长字符串
- 两种方案: HAL_UART_Receive_DMA 和 HAL_UARTEx_ReceiveToIdle_DMA





